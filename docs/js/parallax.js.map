{"version":3,"file":"parallax.js","sources":["parallax.js"],"sourcesContent":["function initializeParallax(clip) {\r\n    var parallax = clip.querySelectorAll('*[parallax]');\r\n    console.log(parallax)\r\n    var parallaxDetails = [];\r\n    var sticky = false;\r\n\r\n    // Edge requires a transform on the document body and a fixed position element\r\n    // in order for it to properly render the parallax effect as you scroll.\r\n    // See https://developer.microsoft.com/en-us/microsoft-edge/platform/issues/5084491/\r\n    if (getComputedStyle(document.body).transform == 'none')\r\n        document.body.style.transform = 'translateZ(0)';\r\n    var fixedPos = document.createElement('div');\r\n    fixedPos.style.position = 'fixed';\r\n    fixedPos.style.top = '0';\r\n    fixedPos.style.width = '1px';\r\n    fixedPos.style.height = '1px';\r\n    fixedPos.style.zIndex = '1';\r\n    document.body.insertBefore(fixedPos, document.body.firstChild);\r\n\r\n    for (var i = 0; i < parallax.length; i++) {\r\n        var elem = parallax[i];\r\n        var container = elem.parentNode;\r\n        if (getComputedStyle(container).overflow != 'visible') {\r\n            console.error('Need non-scrollable container to apply perspective for', elem, container);\r\n            continue;\r\n        }\r\n        if (clip && container.parentNode != clip) {\r\n            console.warn('Currently we only track a single overflow clip, but elements from multiple clips found.', elem);\r\n        }\r\n        var clip = container.parentNode;\r\n        if (getComputedStyle(clip).overflow == 'visible') {\r\n            console.error('Parent of sticky container should be scrollable element', elem);\r\n        }\r\n        // TODO(flackr): optimize to not redo this for the same clip/container.\r\n        var perspectiveElement;\r\n        if (sticky || getComputedStyle(clip).webkitOverflowScrolling) {\r\n            sticky = true;\r\n            perspectiveElement = container;\r\n        } else {\r\n            perspectiveElement = clip;\r\n            container.style.transformStyle = 'preserve-3d';\r\n        }\r\n        perspectiveElement.style.perspectiveOrigin = 'bottom right';\r\n        perspectiveElement.style.perspective = '1px';\r\n        if (sticky)\r\n            elem.style.position = '-webkit-sticky';\r\n        if (sticky)\r\n            elem.style.top = '0';\r\n        elem.style.transformOrigin = 'bottom right';\r\n\r\n        // Find the previous and next elements to parallax between.\r\n        var previousCover = parallax[i].previousElementSibling;\r\n        while (previousCover && previousCover.hasAttribute('parallax'))\r\n            previousCover = previousCover.previousElementSibling;\r\n        var nextCover = parallax[i].nextElementSibling;\r\n        while (nextCover && !nextCover.hasAttribute('parallax-cover'))\r\n            nextCover = nextCover.nextElementSibling;\r\n\r\n        parallaxDetails.push({\r\n            'node': parallax[i],\r\n            'top': parallax[i].offsetTop,\r\n            'sticky': !!sticky,\r\n            'nextCover': nextCover,\r\n            'previousCover': previousCover\r\n        });\r\n    }\r\n\r\n    // Add a scroll listener to hide perspective elements when they should no\r\n    // longer be visible.\r\n    clip.addEventListener('scroll', function () {\r\n        for (var i = 0; i < parallaxDetails.length; i++) {\r\n\r\n            var container = parallaxDetails[i].node.parentNode;\r\n            var previousCover = parallaxDetails[i].previousCover;\r\n            var nextCover = parallaxDetails[i].nextCover;\r\n            var parallaxStart = previousCover ? (previousCover.offsetTop + previousCover.offsetHeight) : 0;\r\n            var parallaxEnd = nextCover ? nextCover.offsetTop : container.offsetHeight;\r\n            var threshold = 200;\r\n            var visible = parallaxStart - threshold - clip.clientHeight < clip.scrollTop &&\r\n                parallaxEnd + threshold > clip.scrollTop;\r\n            // FIXME: Repainting the images while scrolling can cause jank.\r\n            // For now, keep them all.\r\n            // var display = visible ? 'block' : 'none'\r\n            var display = 'block';\r\n            if (parallaxDetails[i].node.style.display != display)\r\n                parallaxDetails[i].node.style.display = display;\r\n        }\r\n    });\r\n    window.addEventListener('resize', onResize.bind(null, parallaxDetails));\r\n    onResize(parallaxDetails);\r\n    for (var i = 0; i < parallax.length; i++) {\r\n        parallax[i].parentNode.insertBefore(parallax[i], parallax[i].parentNode.firstChild);\r\n    }\r\n}\r\n\r\nfunction onResize(details) {\r\n    for (var i = 0; i < details.length; i++) {\r\n        var container = details[i].node.parentNode;\r\n\r\n        var clip = container.parentNode;\r\n        var previousCover = details[i].previousCover;\r\n        var nextCover = details[i].nextCover;\r\n        var rate = details[i].node.getAttribute('parallax');\r\n\r\n        var parallaxStart = previousCover ? (previousCover.offsetTop + previousCover.offsetHeight) : 0;\r\n        var scrollbarWidth = details[i].sticky ? 0 : clip.offsetWidth - clip.clientWidth;\r\n        var parallaxElem = details[i].sticky ? container : clip;\r\n        var height = details[i].node.offsetHeight;\r\n        var depth = 0;\r\n        if (rate) {\r\n            depth = 1 - (1 / rate);\r\n        } else {\r\n            var parallaxEnd = nextCover ? nextCover.offsetTop : container.offsetHeight;\r\n            depth = (height - parallaxEnd + parallaxStart) / (height - clip.clientHeight);\r\n        }\r\n        if (details[i].sticky)\r\n            depth = 1.0 / depth;\r\n\r\n        var scale = 1.0 / (1.0 - depth);\r\n\r\n        // The scrollbar is included in the 'bottom right' perspective origin.\r\n        var dx = scrollbarWidth * (scale - 1);\r\n        // Offset for the position within the container.\r\n        var dy = details[i].sticky ?\r\n            -(clip.scrollHeight - parallaxStart - height) * (1 - scale) :\r\n            (parallaxStart - depth * (height - clip.clientHeight)) * scale;\r\n\r\n        details[i].node.style.transform = 'scale(' + (1 - depth) + ') translate3d(' + dx + 'px, ' + dy + 'px, ' + depth + 'px)';\r\n    }\r\n}"],"names":["initializeParallax","clip","parallax","querySelectorAll","console","log","parallaxDetails","sticky","getComputedStyle","document","body","transform","style","fixedPos","createElement","position","top","width","height","zIndex","insertBefore","firstChild","i","length","elem","container","parentNode","overflow","warn","perspectiveElement","error","webkitOverflowScrolling","transformStyle","perspectiveOrigin","perspective","transformOrigin","previousCover","previousElementSibling","hasAttribute","nextCover","nextElementSibling","push","node","offsetTop","addEventListener","parallaxStart","offsetHeight","parallaxEnd","display","clientHeight","scrollTop","window","onResize","bind","details","rate","getAttribute","scrollbarWidth","offsetWidth","clientWidth","depth","scale","dx","dy","scrollHeight"],"mappings":"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"}